Vue复习

v-if和v-show有什么区别？
    1.v-if和v-show的特点
        1.1：v-if的特點:每次都會重新删除或创建元素，有较高的切换性能消耗

        1.2：v-show的特点:每次不会重新进行DOM的删除和创建操作，只是切换了元素的display：none样式，会有较高的初始渲染消耗

    2.开发中如何选择v-if和v-show
        2.1：如果元素涉及到頻繁的切換，最好不要使用v-if，而是推薦使用 v-show 
        2.2如果元素可能永遠也不會被展示出來被用戶看到，則使用v-if 

Vue中的key有什么作用？（key的内部原理）
    1.虚拟DOM中key的作用：
    key是虚拟DOM对象的标识，当状态中的数据发生变化是，Vue会根据【新数据】生成新的【虚拟DOM】，随后Vue进行【新虚拟DOM】与【旧虚拟DOM】的差异比较，比较规则如下：

    2.对比规则
        2.1.旧虚拟DOM找到了与新虚拟的DOM相同的key：
            2.1.1：若虚拟DOM中内容没变，直接使用之前的真实DOM！

            2.1.2：若虚拟DOM中内容变量，则生成新的真实DOM，随后替换掉页面中之前的真的DOM

        2.2.旧虚拟DOM中未找到与新虚拟DOM相同key，则创建新的真实DOM，随后渲染到页面
    3.用index作为key可能会引起的问题
        3.1.若对数据额进行：一系列逆序操作时会产生没有必要的真实DOM更新===>界面效果没问题，但效率低。

        3.2.如果结构中还包含输入类的DOM会产生错误DOM更新===>界面有问题
    
    4.开发中如何选择key？：
        4.1.最好使用每条数据的唯一标识作为key，比如id.手机号.身份证号.学号等唯一值，
        
        4.2如果不存在对数据的一系列逆序操作，仅有于渲染列表用于展示，使用index作为key是没有问题的

Vue数据监视原理：
    1.Vue会监视data中所有层次的数据

    2.如何检测对象中的数据？
        通过setter实现监视，且要在new Vue时就传入要监测的数据。
        2.1.对象中后追加的属性，Vue默认不做响应式处理
        2.2.如需给后添加的属性做响应式，请使用如下API：
            Vue.set(target.properyName/index.value)或者
            vm.$set(target.properyName/index.value)

    3.如何监测数组中的数据？
        通过包装数组更新元素的方法实现，本质就是做了两件事：
        3.1.调用原生对应的方法对数组进行更新
        3.2.重新解析模板，进而更新页面
    
    4.在Vue修改数组中的某个元素一定要用如下方法
        4.1.使用这些API：push().pop().shift().unshift().solice().sort().reverse()
        4.2.Vue.set()或者vm.$set()

    特别注意：Vue.set() 和 vm.$set()不能给 vm 或 vm的根数据对象添加属性！！！

自定义指令总结：
    1.定义语法：
        1.1.局部指令：
            new Vue({directives:{指令名:配置对象}})
            new Vue({directives:{指令名:回调函数}})
        1.2.全局指令：
            Vue.directive(指令名:配置对象)
            Vue.directive(指令名:回调函数)
    2.配置对象中的常用3个回调：
        2.1.bind:指令与元素成功绑定时调用
        2.2.inserted:指令所在元素被插入页面时调用
        2.3.update:指令所在模板结构被重新解析时调用
    3.备注
        3.1.指令定义时不加v-,但使用时要加v-
        3.2.指令名如果是多个单词,要使用kebab-case命名方式，不要用kebabCase命名

Vue生命周期
    1.vm的一生（vm的生命周期）8个阶段(4组函数)
        1.1.将要创建 ===> 调用beforeCreate函数
            1.1.1.在这个阶段，data和methods中的数据都还没有被初始化，无法通过vm访问到data和methods

        1.2.创建完毕 ===> 调用created函数
            1.2.1.在这个阶段，data和methods都已经被初始化好了，可以通过vm访问到了data和methods

        1.3.将要挂载 ===> 调用beforeMount函数
            1.3.1.此时页面呈现的是 未经Vue编译 的DOM结构
            1.3.2.所有对DOM的操作，最终都不生效

        1.4.挂载完毕 ===> 调用mounted函数
            1.4.1.此时页面中呈现的是经过Vue编译的DOM。
            1.4.2.对DOM的操作均有效("但尽可能避免，因为操作了就是在vue帮你操作完数据后，你又操作了一遍，相当于炒冷饭")。至此初始化过程结束，一般在此进行：发送ajax请求.启动定时器.绑定自定义时间.订阅消息等 "初始化操作"

        1.5.将要更新 ===> 调用beforeUpdate函数
            1.5.1.页面中显示的数据还是旧的，还没被更新 此时data数据还是最新的，页面尚未和最新的数据保持同步

        1.6.更新完毕 ===> 调用updated函数
            1.6.1.页面和data数据已经保持同步了，都是最新的

        1.7.将要销毁 ===> 调用beforeDestroy函数
            1.7.1.此时vm实例会被销毁，但是其中所有的：date,methods,指定等一些操作，都是可用状态，但是不会最终呈现到页面上

        1.8.销毁完毕 ===> 调用destroyed函数
            不常用 在这个阶段vue已经销毁完毕，不能执行跟vue任何相关的操作，但保留原生DOM
    
    2.常用的生命周期钩子:
        2.1.mounted:发送ajax请求.启动定时器.绑定自定义时间.订阅消息等 "初始化操作"
        2.2.beforeDestroy:清理定时器.解绑自定义时间.取消订阅消息等 "收尾工作"

    3.关于销毁Vue实例
        3.1.销毁后借助Vue开发者工具看不到任何信息
        3.2.销毁后自定义时间会失效，但原生DOM时间依旧有效
        3.3.一般不会在beforeDestroy操作数据，因为即使操作数据，也不会在触发更新数据了，(直接干掉，不在走创建=>挂载=>更新流程)   

